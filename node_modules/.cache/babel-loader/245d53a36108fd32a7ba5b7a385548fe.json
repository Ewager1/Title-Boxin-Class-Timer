{"ast":null,"code":"var _jsxFileName = \"/Users/edizzle/Desktop/Web Dev Projects/title-interval-app/title_interal_app/src/pages/IntervalTimer.js\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useEffect, useContext } from \"react\";\nimport { TimerHeader } from \"../components/Timer/TimerHeader\";\nimport { TimerBody } from \"../components/Timer/TimerBody\";\nimport { TimerFooter } from \"../components/Timer/TimerFooter\";\nimport TimerContext from \"../store/timer-context\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport const IntervalTimer = () => {\n  _s();\n\n  // holds all the data used to decide how many rounds, time of each round, etc.\n  const ctx = useContext(TimerContext); //holds current round. used to trigger useEffect for next round\n\n  const [classSegment, setClassSegment] = useState(\"Warmup\"); // made setInterval clearable globally\n\n  const [intervalId, setIntervalId] = useState(); //holds current time state\n\n  const [timer, setTimer] = useState({\n    displayedTime: ctx.isTrainingMode ? \"3:00\" : `${ctx.userChoice.warmUpTime}:00`,\n    minutes: 0,\n    seconds: 0,\n    maxRoundTime: 7\n  }); // pause state\n\n  const [isPaused, setIsPaused] = useState(false);\n  useEffect(() => {\n    //Training mode has its own logic function\n    if (ctx.isTrainingMode) {\n      switch (classSegment) {\n        case \"Warmup\":\n          setTimer(prevState => ({ ...prevState,\n            maxRoundTime: timer.minutes\n          }));\n          setClassSegment(\"Continuous Rounds\");\n          break;\n\n        case \"Continuous Rounds\":\n          setTimer(prevState => ({ ...prevState,\n            maxRoundTime: timer.minutes\n          }));\n          countdown(3, 0);\n          break;\n\n        case `Continuous Active Rest`:\n          setTimer(prevState => ({ ...prevState,\n            maxRoundTime: timer.minutes\n          }));\n          countdown(1, 0);\n          break;\n\n        default:\n      }\n    } else {\n      //regular class timers (not training mode)\n      switch (classSegment) {\n        case \"Warmup\":\n          setTimer(prevState => ({ ...prevState,\n            maxRoundTime: timer.minutes\n          }));\n          countdown(ctx.userChoice.warmUpTime, 0);\n          break;\n\n        case \"Gloves On\":\n          countdown(ctx.userChoice.glovesOnOffTime, 0);\n          break;\n\n        case `Round ${ctx.userChoice.currentRound}`:\n          countdown(ctx.userChoice.roundTime, 0);\n          setTimer(prevState => ({ ...prevState,\n            maxRoundTime: timer.minutes\n          }));\n          break;\n\n        case \"Active Rest\":\n          countdown(ctx.userChoice.activeRestTime, 0);\n          setTimer(prevState => ({ ...prevState,\n            maxRoundTime: timer.minutes\n          }));\n          break;\n\n        case \"Gloves Off\":\n          countdown(ctx.userChoice.glovesOnOffTime, 0);\n          setTimer(prevState => ({ ...prevState,\n            maxRoundTime: timer.minutes\n          }));\n          break;\n\n        case \"Core\":\n          countdown(ctx.userChoice.coreTime, 0);\n          setTimer(prevState => ({ ...prevState,\n            maxRoundTime: timer.minutes\n          }));\n          break;\n\n        default:\n      }\n    }\n\n    return () => {\n      clearInterval(intervalId);\n    };\n  }, [classSegment]); //inputs minutes and seconds and outputs a timer in conjunction with state\n\n  const countdown = (numOfMinutes, numOfSeconds) => {\n    let minutes = numOfMinutes;\n    let seconds = numOfSeconds;\n    const interval = setInterval(() => {\n      let digit = seconds < 10 ? \"0\" : \"\";\n      setTimer(prevState => ({ ...prevState,\n        minutes: minutes,\n        seconds: seconds,\n        displayedTime: `${minutes}:${digit}${seconds}`\n      }));\n      seconds--;\n\n      if (minutes === 0 && seconds < 0) {\n        clearInterval(interval);\n        ctx.isTrainingMode ? handleTrainingMode() : handleClassSegment();\n      }\n\n      if (minutes > 0 && seconds < 0) {\n        minutes--;\n        seconds = 59;\n      }\n    }, 1000);\n    setIntervalId(interval);\n  }; //handles natural logic flow\n\n\n  const handleClassSegment = () => {\n    switch (classSegment) {\n      case \"Warmup\":\n        setClassSegment(\"Gloves On\");\n        break;\n\n      case \"Gloves On\":\n        setClassSegment(`Round ${ctx.userChoice.currentRound}`);\n        break;\n\n      case `Round ${ctx.userChoice.currentRound}`:\n        if (ctx.userChoice.currentRound === ctx.userChoice.totalRounds) {\n          setClassSegment(\"Gloves Off\");\n        } else {\n          ctx.setuserChoice({ ...ctx.userChoice,\n            currentRound: ctx.userChoice.currentRound += 1\n          });\n          setClassSegment(\"Active Rest\");\n        }\n\n        break;\n\n      case \"Active Rest\":\n        setClassSegment(`Round ${ctx.userChoice.currentRound}`);\n        break;\n\n      case \"Gloves Off\":\n        setClassSegment(\"Core\");\n        break;\n\n      case \"Core\":\n        console.log(\"class done, this will reroute to home page \");\n        break;\n\n      default:\n    }\n  };\n\n  const handleTrainingMode = () => {\n    switch (classSegment) {\n      case \"Warmup\":\n        setClassSegment(\"Continuous Rounds\");\n        break;\n\n      case \"Continuous Rounds\":\n        setClassSegment(\"Continuous Active Rest\");\n        break;\n\n      case \"Continuous Active Rest\":\n        setClassSegment(\"Continuous Rounds\");\n        break;\n\n      default:\n    }\n  };\n\n  const pause = () => {\n    clearInterval(intervalId);\n    setIsPaused(true);\n  };\n\n  const play = () => {\n    countdown(timer.minutes, timer.seconds);\n    setIsPaused(false);\n  };\n\n  const rewind = () => {\n    console.log(timer.maxRoundTime);\n    let addedMinute = timer.minutes + 1;\n    let addedSeconds = timer.seconds + 15 - 60;\n    clearInterval(intervalId);\n\n    if (timer.seconds < 45) {\n      countdown(timer.minutes, timer.seconds + 15);\n    } else if (timer.seconds >= 45 && timer.minutes + 1 >= timer.maxRoundTime) {\n      console.log(\"max time\");\n      countdown(timer.maxRoundTime, 0);\n    } else {\n      console.log(timer.minutes, timer.maxRoundTime);\n      countdown(addedMinute, addedSeconds);\n    }\n  };\n\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(TimerHeader, {\n      handleClearInterval: () => clearInterval\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 202,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(TimerBody, {\n      displayedTime: timer.displayedTime,\n      play: play,\n      pause: pause,\n      isPaused: isPaused,\n      rewind: rewind\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 204,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(TimerFooter, {\n      classSegment: classSegment\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 211,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true);\n};\n\n_s(IntervalTimer, \"Yir/OMPfDsgfRvAr9COwoMeKgqc=\");\n\n_c = IntervalTimer;\n\nvar _c;\n\n$RefreshReg$(_c, \"IntervalTimer\");","map":{"version":3,"sources":["/Users/edizzle/Desktop/Web Dev Projects/title-interval-app/title_interal_app/src/pages/IntervalTimer.js"],"names":["React","useState","useEffect","useContext","TimerHeader","TimerBody","TimerFooter","TimerContext","IntervalTimer","ctx","classSegment","setClassSegment","intervalId","setIntervalId","timer","setTimer","displayedTime","isTrainingMode","userChoice","warmUpTime","minutes","seconds","maxRoundTime","isPaused","setIsPaused","prevState","countdown","glovesOnOffTime","currentRound","roundTime","activeRestTime","coreTime","clearInterval","numOfMinutes","numOfSeconds","interval","setInterval","digit","handleTrainingMode","handleClassSegment","totalRounds","setuserChoice","console","log","pause","play","rewind","addedMinute","addedSeconds"],"mappings":"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","sourcesContent":["import React, { useState, useEffect, useContext } from \"react\";\n\nimport { TimerHeader } from \"../components/Timer/TimerHeader\";\nimport { TimerBody } from \"../components/Timer/TimerBody\";\nimport { TimerFooter } from \"../components/Timer/TimerFooter\";\n\nimport TimerContext from \"../store/timer-context\";\n\nexport const IntervalTimer = () => {\n  // holds all the data used to decide how many rounds, time of each round, etc.\n  const ctx = useContext(TimerContext);\n\n  //holds current round. used to trigger useEffect for next round\n  const [classSegment, setClassSegment] = useState(\"Warmup\");\n\n  // made setInterval clearable globally\n  const [intervalId, setIntervalId] = useState();\n\n  //holds current time state\n  const [timer, setTimer] = useState({\n    displayedTime: ctx.isTrainingMode\n      ? \"3:00\"\n      : `${ctx.userChoice.warmUpTime}:00`,\n    minutes: 0,\n    seconds: 0,\n    maxRoundTime: 7\n  });\n  // pause state\n  const [isPaused, setIsPaused] = useState(false);\n\n  useEffect(() => {\n    //Training mode has its own logic function\n    if (ctx.isTrainingMode) {\n      switch (classSegment) {\n        case \"Warmup\":\n          setTimer(prevState => ({...prevState, maxRoundTime: timer.minutes }))\n          setClassSegment(\"Continuous Rounds\");\n          break;\n        case \"Continuous Rounds\":\n          setTimer(prevState => ({...prevState, maxRoundTime: timer.minutes }))\n\n          countdown(3, 0);\n          break;\n        case `Continuous Active Rest`:\n          setTimer(prevState => ({...prevState, maxRoundTime: timer.minutes }))\n          countdown(1, 0);\n          break;\n        default:\n      }\n    } else {\n      //regular class timers (not training mode)\n      switch (classSegment) {\n        case \"Warmup\":\n          setTimer(prevState => ({...prevState, maxRoundTime: timer.minutes }))\n          countdown(ctx.userChoice.warmUpTime, 0); \n          \n          break;\n        case \"Gloves On\":\n          countdown(ctx.userChoice.glovesOnOffTime, 0);\n       \n          break;\n        case `Round ${ctx.userChoice.currentRound}`:\n          countdown(ctx.userChoice.roundTime, 0);\n          setTimer(prevState => ({...prevState, maxRoundTime: timer.minutes }))\n          break;\n        case \"Active Rest\":\n          countdown(ctx.userChoice.activeRestTime, 0);\n          setTimer(prevState => ({...prevState, maxRoundTime: timer.minutes }))\n\n          break;\n        case \"Gloves Off\":\n          countdown(ctx.userChoice.glovesOnOffTime, 0);\n          setTimer(prevState => ({...prevState, maxRoundTime: timer.minutes }))\n          break;\n        case \"Core\":\n          countdown(ctx.userChoice.coreTime, 0);\n          setTimer(prevState => ({...prevState, maxRoundTime: timer.minutes }))\n          break;\n        default:\n      }\n    }\n   \n    return () => {\n      clearInterval(intervalId);\n    };\n  }, [classSegment]);\n\n  //inputs minutes and seconds and outputs a timer in conjunction with state\n  const countdown = (numOfMinutes, numOfSeconds) => {\n    let minutes = numOfMinutes;\n    let seconds = numOfSeconds;\n\n  \n    const interval = setInterval(() => {\n      let digit = seconds < 10 ? \"0\" : \"\";\n\n      setTimer(\n        prevState => ({ ...prevState, \n        minutes: minutes,\n        seconds: seconds,\n        displayedTime: `${minutes}:${digit}${seconds}`,\n      }))\n\n      seconds--;\n\n      if (minutes === 0 && seconds < 0) {\n        clearInterval(interval);\n        ctx.isTrainingMode ? handleTrainingMode() :  handleClassSegment();\n      } \n      \n      if (minutes > 0 && seconds < 0) {\n        minutes--;\n        seconds = 59;\n      }\n    }, 1000);\n    setIntervalId(interval);\n  };\n\n\n  //handles natural logic flow\n  const handleClassSegment = () => {\n    switch (classSegment) {\n      case \"Warmup\":\n        setClassSegment(\"Gloves On\");\n        break;\n      case \"Gloves On\":\n        setClassSegment(`Round ${ctx.userChoice.currentRound}`);\n        break;\n      case `Round ${ctx.userChoice.currentRound}`:\n        if (ctx.userChoice.currentRound === ctx.userChoice.totalRounds) {\n          setClassSegment(\"Gloves Off\");\n        } else {\n          ctx.setuserChoice({\n            ...ctx.userChoice,\n            currentRound: (ctx.userChoice.currentRound += 1),\n          });\n          setClassSegment(\"Active Rest\");\n        }\n        break;\n      case \"Active Rest\":\n        setClassSegment(`Round ${ctx.userChoice.currentRound}`);\n\n        break;\n      case \"Gloves Off\":\n        setClassSegment(\"Core\");\n        break;\n      case \"Core\":\n        console.log(\"class done, this will reroute to home page \");\n        break;\n      default:\n    }\n  };\n\n  const handleTrainingMode = () => {\n    switch (classSegment) {\n      case \"Warmup\":\n        setClassSegment(\"Continuous Rounds\");\n        break;\n      case \"Continuous Rounds\":\n        setClassSegment(\"Continuous Active Rest\");\n        break;\n      case \"Continuous Active Rest\":\n        setClassSegment(\"Continuous Rounds\");\n        break;\n      default:\n    }\n  };\n\n  const pause = () => {\n    clearInterval(intervalId);\n    setIsPaused(true);\n  };\n\n  const play = () => {\n    countdown(timer.minutes, timer.seconds);\n    setIsPaused(false);\n  };\n\n  const rewind = () =>{\n    console.log(timer.maxRoundTime)\n    let addedMinute = timer.minutes + 1 \n    let addedSeconds = timer.seconds + 15 - 60\n    clearInterval(intervalId)\n\n    if(timer.seconds < 45){  \n    countdown(timer.minutes, timer.seconds +15)}\n    else if (timer.seconds >= 45 && timer.minutes + 1 >= timer.maxRoundTime){\n      console.log(\"max time\")\n      countdown(timer.maxRoundTime, 0)\n    }\n    else { \n      console.log(timer.minutes, timer.maxRoundTime)\n      countdown(addedMinute, addedSeconds)\n    }\n\n  };\n\n\n\n  return (\n    <>\n      <TimerHeader\n      handleClearInterval={() => clearInterval} />\n      <TimerBody\n        displayedTime={timer.displayedTime}\n        play={play}\n        pause={pause}\n        isPaused={isPaused}\n        rewind={rewind}\n      />\n      <TimerFooter classSegment={classSegment} /> \n    </>\n  );\n};\n"]},"metadata":{},"sourceType":"module"}